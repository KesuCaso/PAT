# PAT

æŠŠPATåˆ·é¢˜æä¸Šæ—¥ç¨‹ä¹‹åï¼Œç„¶è€Œå­¦æ ¡ä½œä¸šç‹‚è½°æ»¥ç‚¸ï¼Œæ‹–åˆ°è¿™ä¸ªæ—¶å€™ï¼Œç»ˆäºå¼€å§‹ç€æ‰‹äº†T_T

## 1001 A+B Format

### **ğŸ“œé¢˜ç›®**

Calculate *a*+*b* and output the sum in standard format -- that is, the digits must be separated into **groups of three by commas** (unless there are less than four digits).

Input Specification:

Each input file contains one test case. Each case contains a pair of integers *a* and *b* where âˆ’10^6â‰¤*a*,*b*â‰¤10^6. The numbers are separated by a space.

Output Specification:

For each test case, you should output the sum of *a* and *b* in one line. The sum must be written in the standard format.

Sample Input:

```in
-1000000 9
```

Sample Output:

```out
-999,991
```

### **ğŸ¤”æ€è·¯**

çœ‹åˆ°é¢˜ç›®ä¸­è¯´äº†a,bçš„èŒƒå›´ï¼Œæ„Ÿè§‰å¯ä»¥ç”¨æš´åŠ›è§£æ³•(ä¸æ–­åˆ†ç±»)ï¼Œå› ä¸ºå¼€å§‹æ²¡æƒ³åˆ°ç”¨stringæ¥åšï¼Œå°±æƒ³ç€ç”¨çº¯intæ¥ä¸æ–­æ•´é™¤å–æ•´(ä½†å®é™…ä¸Šæ˜¯éå¸¸æ„šè ¢çš„åšæ³•...å“ğŸ˜­è¿˜æ˜¯é¢˜åˆ·å°‘äº†...æ²¡äº‹ï¼Œæ…¢æ…¢æ¥ï¼)å‚è€ƒäº†æŸ³ç¥çš„ä»£ç ï¼Œæ„Ÿè§‰éå¸¸ç®€æ´ï¼Œå­¦åˆ°äº†ï¼ä¸äºæ˜¯æŸ³ç¥ï¼æŠŠå’Œå½“ä½œstringæ•°ç»„ï¼Œç„¶åæ¯æ¬¡é‡åˆ°æ»¡è¶³æ¡ä»¶å°±è¾“å‡ºä¸€ä¸ªé€—å·ã€‚

ğŸ“•**æ ¸å¿ƒæ€æƒ³**ï¼šæ•´ä½“ä¸€ä¸²æ•°å­—é™¤ä»¥3ï¼Œç•™ä¸‹çš„å°±æ˜¯ä»ä½ä½åˆ°é«˜ä½å‰©ä¸‹æ¥çš„æ•°å­—ï¼Œæ‰€ä»¥ä»é«˜ä½å¼€å§‹ä¸€é‡åˆ°è¿™ä¸ªæ•°å­—å°±è¦åœä¸‹æ¥è¾“å‡º','ã€‚

### **â­ä»£ç **

```c++
#include<iostream>
#include<string>
using namespace std;

int main(){
    int m,n,sum;
    cin>>m>>n;
    sum = m+n;
    string res;
    //è®°å¾—ä¸€å®šè¦è½¬æ¢æˆstringæ•°ç»„æ‰ç®€å•ï¼
    res = to_string(sum);//åƒä¸‡è¦è®°å¾—stringåº“ä¸­çš„è½¬æ¢å‡½æ•°ï¼
    int len = res.length(); //ä¸åŒäºpythonå“¦~
    for(int i=0;i<len;i++){
        cout<<res[i];
        if (res[i]=='-')
            continue;
        //æ ¸å¿ƒçš„ä»£ç æ€æƒ³
        //å¦‚æœå½“å‰çš„ä½ç½®å’Œæ•´ä½“é•¿åº¦é™¤3å–æ•´ç›¸ç­‰å¹¶ä¸”ä¸æ˜¯æœ€åä¸€ä¸ªå…ƒç´ 
        if((i+1)%3==len%3&&i!=len-1)
            cout<<",";
    }
    return 0;
}
```

### **ğŸ“æŸ¥æ¼è¡¥ç¼º**

```c++
//å‡½æ•°çš„ä½¿ç”¨
//intè½¬string
string s = to_string(int value);
//stringçš„é•¿åº¦
s.length();
//stringå¯ä»¥å½“ä½œæ•°ç»„ä½¿ç”¨ï¼Œä¸‹æ ‡å¯ä»¥å®šä½
```

è®°å½•ä¸€ä¸‹ç¬¬ä¸€æ¬¡æäº¤ğŸ˜Š~

![image-20200512113820943](C:\Users\Surface\AppData\Roaming\Typora\typora-user-images\image-20200512113820943.png)

**â—** pythonæ•²å¤šäº†å°±ç»å¸¸å¿˜è®°å†™é€—å·:( ä¸€å®šè¦æ”¹æ­£è¿‡æ¥

## 1002 A+B Polynomials

### **ğŸ“œé¢˜ç›®**

This time, you are supposed to find *A*+*B* where *A* and *B* are two **polynomials**.

Input Specification:

Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:
$$
KN_1a_{N_1}N_2a_{N_2}...N_Ka_{N_k}
$$
where *K* is the number of **nonzero terms** in the polynomial, *N_i* and *aNi* (*i*=1,2,â‹¯,*K*) are the **exponents and coefficients**, respectively. It is given that 1â‰¤*K*â‰¤10ï¼Œ0â‰¤*N_K*<â‹¯<N_2<N_1<**1000.**

Output Specification:

For each test case you should output the sum of *A* and *B* in one line, with the same format as the input. Notice that there must be **NO extra space** at the end of each line. Please be accurate to **1 decimal place**.

Sample Input:

```in
2 1 2.4 0 3.2
2 2 1.5 1 0.5
```

Sample Output:

```out
3 2 1.5 1 2.9 0 3.2
```

### ğŸ¤”æ€è·¯

çœ‹åˆ°é¢˜ç›®çš„æ—¶å€™æ•´ä¸ªäººæ‡µäº†ä¸€ä¸‹ï¼Œå› ä¸ºæ²¡å¤ªçœ‹æ‡‚é¢˜ğŸ˜‚ï¼Œç¢ç£¨äº†ä¸€ä¸‹å‘ç°äº†é¢˜ç›®æ„æ€ï¼Œç„¶åæƒ³åˆ°å‰æ®µæ—¶é—´çœ‹è¿‡ä¸€ä¸ªç±»ä¼¼é¢˜ç›®ï¼Œæ•°ç»„çš„å†…å®¹å¯ä»¥ä½œä¸ºç´¢å¼•æ•°ç»„çš„ä¸‹æ ‡æ¥è®°å½•ä½ç½®ï¼Œæ‰€ä»¥å°±ç«‹åˆ»å¼€å§‹ç€æ‰‹ä»£ç ã€‚ä½†æ˜¯è¿è¡Œçš„æ—¶å€™åœ¨è¾“å…¥çš„æ—¶å€™é‡åˆ°äº†éº»çƒ¦ï¼Œæœ¬æ¥æƒ³ç€ç”¨æ•°ç»„è¾“å…¥ï¼Œä½†æ˜¯è¿™æ ·ä¸ç¡®å®šæ•°ç»„çš„ä¸ªæ•°ä¹Ÿä¸çŸ¥é“ä»€ä¹ˆæ—¶å€™è¾“å…¥ç»“æŸï¼Œæ‰€ä»¥è¿˜æ˜¯è¦ä»¥æ•°å­—è¾“å…¥ï¼Œç”¨Kå€¼è®¡æ•°å°±å¥½äº†~

ğŸ“•æ ¸å¿ƒæ€æƒ³ï¼šæŒ‡æ•°ç›¸åŒçš„è¦æ”¾åœ¨ä¸€èµ·ï¼Œæ‰€ä»¥ç”¨ä¸€ä¸ªæ–°çš„ç´¢å¼•æ•°ç»„æ¥å­˜æ”¾ç›¸åŒæŒ‡æ•°çš„ç³»æ•°ï¼›è¾“å…¥è¾“å‡ºçš„æ—¶å€™åˆ†æ‰¹è¾“å…¥ï¼›è¾“å‡ºè®°å¾—ç”¨ä¿ç•™ä¸€ä½å°æ•°ï¼Œæ‰€ä»¥scanfå’Œprintféƒ½æ¯”cinã€coutå¥½ç”¨ã€‚

### â­ä»£ç 

```C++
#include<iostream>
using namespace std;

int main() {
	int m, n;//åˆ†åˆ«ä»£è¡¨ä¸¤ç»„è¾“å…¥çš„Kå€¼
	int exp;//æŒ‡æ•°
	float coef;//ç³»æ•°
	float index[1001] = { 0.0 };//ä¸ºäº†è®°å½•ç›¸åŒçš„æŒ‡æ•°çš„ä¸ªæ•°

	cin >> m;
	for (int i = 0; i < m; i++) {
		cin >> exp >> coef;
		index[exp] += coef;//æŒ‡æ•°ç›¸åŒçš„å°±åŠ åœ¨ä¸€èµ·
	}
	cin >> n;
	for (int i = 0; i < n; i++) {
		cin >> exp >> coef;
		index[exp] += coef;
	}
	int cnt = 0;//è®°å½•æœ€åçš„å’Œçš„Kå€¼
	for (int i = 0; i < 1001; i++) {
		if (index[i] != 0.0) cnt++;
	}
	cout << cnt;
	for (int i = 1000; i >= 0; i--) {
		if (index[i] != 0.0)
			//cout << ' ' << i << ' ' << index[i];
            //ä¸€ä½å°æ•°è¾“å‡ºï¼Œæ‰€ä»¥æ”¹æˆprintf
        	printf(" %d %.1f", i, index[i]);

	}
    return 0;
}
```

ç¬¬ä¸€æ¬¡æäº¤å¹¶æ²¡æœ‰å®Œå…¨é€šè¿‡ï¼Œè€Œç¬¬äºŒæ¬¡å°†è¾“å‡ºæ”¹å˜å°±é€šè¿‡äº†ã€‚

![image-20200512224937776](C:\Users\Surface\AppData\Roaming\Typora\typora-user-images\image-20200512224937776.png)

### ğŸ“æŸ¥æ¼è¡¥ç¼º

```C++
//è¾“å‡ºä¸€ä½å°æ•°
printf("%.1f",num);
```

## 1003 Emergency

### **ğŸ“œé¢˜ç›®**

As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.

Input Specification:

Each input file contains one test case. For each test case, the first line contains 4 positive integers: ***N*** (â‰¤500) - **the number of cities** (and the cities are numbered from 0 to *N*âˆ’1), ***M*** - **the number of roads**, ***C*1 and *C*2** - **the cities that you are currently in and that you must save**, respectively. The next line contains *N* integers, where the *i*-th integer is **the number of rescue teams** in the *i*-th city. Then *M* lines follow, each describes a road with three integers *c*1, *c*2 and *L*, which are the **pair of cities** connected by a road and th**e length of that road**, respectively. It is guaranteed that there exists at least one path from *C*1 to *C*2.

Output Specification:

For each test case, print in one line two numbers: **the number of different shortest paths** between *C*1 and *C*2, and the **maximum amount of rescue teams** you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.

Sample Input:

```in
5 6 0 2
1 2 1 5 3
0 1 1
0 2 2
0 3 1
1 2 1
2 4 1
3 4 1
```

Sample Output

```out
2 4
```

### **ğŸ¤”æ€è·¯**

çœ‹åˆ°é¢˜ç›®ä¸€é•¿ä¸²å°±è§‰å¾—å¾ˆæ™•ğŸ˜”ç„¶åä»”ç»†è¯»é¢˜ç›®ï¼Œå‘ç°æ˜¯ä¸€ä¸ªæœ€çŸ­è·¯å¾„é¢˜ã€‚ç„¶åå°±æƒ³åˆ°dijkstraç®—æ³•ï¼Œå¥ˆä½•æˆ‘å¹¶ä¸ä¼šå†™è¿™ä¸ªç®—æ³•çš„ä»£ç ğŸ˜­äºæ˜¯å°±å¤ä¹ è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•ï¼Œçœ‹äº†ä¸€äº›åšå®¢ï¼Œç”±äºé¢˜ç›®ä¸­æ˜¯æ‰¾æœ€çŸ­è·¯å¾„çš„æ¡æ•°ï¼Œæ‰€ä»¥ç¢ç£¨åŠå¤©è¿˜æ˜¯ä¸ä¼šå†™ä»£ç ...æ‰€ä»¥å°±çœ‹äº†æŸ³ç¥çš„ä»£ç ã€‚T_TæŸ³ç¥çš„ä»£ç çœ‹æ˜ç™½éƒ½è¦èŠ±è´¹ç‚¹æ—¶é—´...

**ğŸ“•æ ¸å¿ƒæ€æƒ³**ï¼šç”¨ä¸€éDijkstraç®—æ³•ï½æ•‘æ´å°ç»„ä¸ªæ•°ç›¸å½“äºç‚¹æƒï¼Œç”¨Dijkstraæ±‚è¾¹æƒæœ€å°çš„æœ€çŸ­è·¯å¾„çš„æ¡æ•°ï¼Œä»¥åŠè¿™äº›æœ€çŸ­è·¯å¾„ä¸­ç‚¹æƒæœ€å¤§çš„å€¼ï½dis[i]è¡¨ç¤ºä»å‡ºå‘ç‚¹åˆ°iç»“ç‚¹æœ€çŸ­è·¯å¾„çš„è·¯å¾„é•¿åº¦ï¼Œnum[i]è¡¨ç¤ºä»å‡ºå‘ç‚¹åˆ°iç»“ç‚¹æœ€çŸ­è·¯å¾„çš„æ¡æ•°ï¼Œw[i]è¡¨ç¤ºä»å‡ºå‘ç‚¹åˆ°iç‚¹æ•‘æ´é˜Ÿçš„æ•°ç›®ä¹‹å’Œï½å½“åˆ¤å®šdis[u] + e[u] [v]< dis[v]çš„æ—¶å€™ï¼Œä¸ä»…ä»…è¦æ›´æ–°dis[v]ï¼Œè¿˜è¦æ›´æ–°num[v] = num[u], w[v] = weight[v] + w[u]; å¦‚æœdis[u] + e[u] [v] == dis[v]ï¼Œè¿˜è¦æ›´æ–°num[v] += num[u]ï¼Œè€Œä¸”åˆ¤æ–­ä¸€ä¸‹æ˜¯å¦æƒé‡w[v]æ›´å°ï¼Œå¦‚æœæ›´å°äº†å°±æ›´æ–°w[v] = weight[v] + w[u]; 

### â­**ä»£ç **

```c++
#include <iostream>
#include <algorithm>
using namespace std;
int n, m, c1, c2;
//åŸå¸‚ä¹‹é—´çŸ©é˜µ,æ¯ä¸ªåŸå¸‚çš„æ•‘æ´æ•°,æœ€çŸ­è·¯å¾„,æœ€çŸ­è·¯å¾„çš„æ•°ç›®,æœ€å¤šçš„æ•‘æ´æ•°ç›®
int e[510][510], weight[510], dis[510], num[510], w[510];
bool visit[510];
const int inf = 99999999;
int main() {
    //è¾“å…¥çš„ç¬¬ä¸€è¡Œ
    //næ˜¯åŸå¸‚æ•°,mæ˜¯é“è·¯æ•°,c1æ˜¯æ‰€åœ¨åŸå¸‚,c2æ˜¯ç›®çš„åŸå¸‚
    scanf("%d%d%d%d", &n, &m, &c1, &c2);
    //è¾“å…¥çš„ç¬¬äºŒè¡Œ
    //æ¯ä¸€ä¸ªåŸå¸‚çš„æ•‘æ´é˜Ÿæ•°é‡
    for(int i = 0; i < n; i++)
        scanf("%d", &weight[i]);
    //èµ‹å€¼æ•°ç»„
    fill(e[0], e[0] + 510 * 510, inf);
    fill(dis, dis + 510, inf);
    //è¾“å…¥ç¬¬ä¸‰éƒ¨åˆ†
    int a, b, c;
    for(int i = 0; i < m; i++) {
        scanf("%d%d%d", &a, &b, &c);
        //è¿æ¥é“è·¯çš„é‚»æ¥çŸ©é˜µ
        e[a][b] = e[b][a] = c;
    }
    dis[c1] = 0;    //å‡ºå‘ç‚¹åˆ°å‡ºå‘ç‚¹çš„è·ç¦»ä¸º0
    w[c1] = weight[c1];   //å‡ºå‘ç‚¹åˆ°å‡ºå‘ç‚¹çš„æ•‘æ´æ•°ç›®
    num[c1] = 1;    //å‡ºå‘ç‚¹åˆ°å‡ºå‘ç‚¹çš„æœ€çŸ­è·¯å¾„æ•°ç›®ä¸º1
    //å¤§å¾ªç¯ï¼Dijkstraçš„å…³é”®
    for(int i = 0; i < n; i++) {
        int u = -1, minn = inf;
        for(int j = 0; j < n; j++) {
            //å¦‚æœæ²¡è®¿é—®è¿‡å¹¶ä¸”è·¯å¾„æ›´çŸ­äº†å°±æ›´æ–°
            //æœ€å¼€å§‹çš„æ—¶å€™å°±æ˜¯æœ¬èº«çš„åœ°ç‚¹
            //åé¢å°±æ˜¯ç¦»å‡ºå‘ç‚¹æœ€è¿‘çš„åœ°ç‚¹äº† éå†æ˜¯ä¸ºäº†æ‰¾æœ€è¿‘ï¼
            if(visit[j] == false && dis[j] < minn) {
                u = j;
                minn = dis[j];
            }
        }
        if(u == -1) break;
        visit[u] = true;//æœ€è¿‘ç»“ç‚¹å·²æ‰¾åˆ°
        for(int v = 0; v < n; v++) {
            //é€ç‚¹æ‰¾æ˜¯å¦å¯ä»¥æ›´æ–°è·ç¦»çš„ç»“ç‚¹
            if(visit[v] == false && e[u][v] != inf) {
                //uæˆä¸ºä¸­é—´ç‚¹
                if(dis[u] + e[u][v] < dis[v]) {
                    dis[v] = dis[u] + e[u][v];
                    num[v] = num[u];
                    w[v] = w[u] + weight[v];
                } else if(dis[u] + e[u][v] == dis[v]) {
                    num[v] = num[v] + num[u];
                    if(w[u] + weight[v] > w[v])
                        w[v] = w[u] + weight[v];
                }
            }
        }
    }
    printf("%d %d", num[c2], w[c2]);
    return 0;
}
```

### **ğŸ“æŸ¥æ¼è¡¥ç¼º**

```c++
//Dijkstraç®—æ³•è¯¦ç»†è¯·çœ‹ç®—æ³•ç¬”è®°
//ğŸ“•å¤§æ•°ç»„ä¸€å®šè¦å¼€å…¨å±€ï¼Œè€Œä¸æ˜¯å†™åœ¨mainå‡½æ•°é‡Œé¢ï¼Œå¦åˆ™å®¹æ˜“å‘ç”Ÿæ®µé”™è¯¯ï¼ˆå› ä¸ºå¤§æ•°ç»„åœ¨mainå‡½æ•°é‡Œé¢çš„è¯æ˜¯å­˜å‚¨åœ¨æ ˆé‡Œï¼Œè€Œæ ˆç©ºé—´æ˜¯åœ¨è¿›ç¨‹åˆ›å»ºæ—¶åˆå§‹åŒ–çš„ï¼Œæœ‰å›ºå®šçš„å¤§å°ï¼Œä¸€èˆ¬ä¸ºå‡ åKBï¼Œæ‰€ä»¥å¤ªå¤§çš„æ•°ç»„ä¼šè€—å…‰æ ˆç©ºé—´ã€‚è€Œå…¨å±€å˜é‡å ç”¨çš„å †ç©ºé—´ï¼Œå †ç©ºé—´ä¸­çš„å†…å­˜æ˜¯æŒ‰éœ€åˆ†é…ï¼Œè‡ªç”±å¢é•¿çš„ï¼Œå¯ä»¥éå¸¸å¤§ï¼Œæ¯”å¦‚32ä½çš„ç³»ç»Ÿä¸­å¯ä»¥å¤§åˆ°4GBã€‚å°†å¤§æ•°ç»„æ”¾åœ¨å…¨å±€å˜é‡ä¸­èƒ½é¿å…æ ˆæº¢å‡ºï½
//fillå‡½æ•° åœ¨å¤´æ–‡ä»¶<algorithm>é‡Œé¢
#include <algorithm>
fill(arr, arr + n, è¦å¡«å…¥çš„å†…å®¹);
https://blog.csdn.net/liuchuo/article/details/52296646
```

## 1004 Counting Leaves

### **ğŸ“œé¢˜ç›®**

A family hierarchy is usually presented by a **pedigree**(è°±ç³») tree. Your job is to count those family **members who have no child**.

Input Specification:

Each input file contains one test case. Each case starts with a line containing 0<***N***<100, **the number of nodes in a tree**, and **M** (<N), the number of **non-leaf nodes.** Then *M* lines follow, each in the format:

```
ID K ID[1] ID[2] ... ID[K]
```

where `ID` is a two-digit number representing a given non-leaf node, `K` is the number of **its children**(æˆ‘çš„ç†è§£æ˜¯æœ€ç›´æ¥çš„å­èŠ‚ç‚¹), followed by a sequence of two-digit `ID`'s of its children. For the sake of simplicity, let us fix the **root ID** to be `01`.

The input ends with ***N* being 0**. That case must NOT be processed.

Output Specification:

For each test case, you are supposed to count those family members who **have no child** **for every seniority level** starting from the root. The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line.

The sample case represents a tree with only 2 nodes, where `01` is the root and `02` is its only child. Hence on the root `01` level, there is `0` leaf node; and on the next level, there is `1` leaf node. Then we should output `0 1` in a line.

Sample Input

```in
2 1
01 1 02
```

Sample Output:

```out
0 1
```

### **ğŸ¤”æ€è·¯**

çœ‹äº†åŠå¤©é¢˜ç›®æ‰çœ‹æ‡‚é¢˜ç›®...ç„¶åå‘ç°æ˜¯bfsã€dfsçš„é¢˜ï¼Œéå†æ¯ä¸€å±‚æ‰¾æ²¡æœ‰å­©å­çš„èŠ‚ç‚¹è¾“å‡ºå°±è¡Œï¼Œæœ¬æ¥å¼€å§‹æƒ³ç”¨bfsï¼Œå› ä¸ºæ˜¯æ¯ä¸€å±‚ä¸€å±‚åœ°æ¥ï¼Œæ‰€ä»¥å°±åº”è¯¥æ˜¯å¹¿åº¦ä¼˜å…ˆï¼Œä½†æ˜¯åŠå¤©å†™ä¸å‡ºä»£ç æ¥ï¼Œæœ€åçœ‹äº†æŸ³ç¥çš„ä»£ç ï¼Œç”¨æ·±åº¦ä¼˜å…ˆï¼Œç›´æ¥é€’å½’ï¼Œè¿™æ ·å°±ç®€å•äº†å¾ˆå¤šã€‚

**ğŸ“•æ ¸å¿ƒæ€æƒ³**ï¼šç»™å‡ºä¸€æ£µæ ‘ï¼Œé—®æ¯ä¸€å±‚å„æœ‰å¤šå°‘ä¸ªå¶å­ç»“ç‚¹ï½å¯ä»¥ç”¨dfsä¹Ÿå¯ä»¥ç”¨bfsï½å¦‚æœç”¨dfsï¼Œç”¨äºŒç»´æ•°ç»„ä¿å­˜æ¯ä¸€ä¸ªæœ‰å­©å­ç»“ç‚¹çš„ç»“ç‚¹ä»¥åŠä»–ä»¬çš„å­©å­ç»“ç‚¹ï¼Œä»æ ¹ç»“ç‚¹å¼€å§‹éå†ï¼Œç›´åˆ°é‡åˆ°å¶å­ç»“ç‚¹ï¼Œå°±å°†å½“å‰å±‚æ•°depthçš„book[depth]++ï¼›æ ‡è®°ç¬¬depthå±‚æ‹¥æœ‰çš„å¶å­ç»“ç‚¹æ•°ï¼Œæœ€åè¾“å‡ºï½

### â­**ä»£ç **

```c++
#include<iostream>
#include<queue>
#include<vector>
using namespace std;

//å¤§æ•°ç»„éƒ½å¼€å…¨å±€ï¼
vector<int> child[101];//å®šä¹‰ä¸€ä¸ªè£…å­èŠ‚ç‚¹çš„vector äºŒç»´çš„å‘é‡
int cnt[101]={0};
int maxlevel=-1;//è®°å½•æ ‘çš„é«˜åº¦
void dfs(int start,int level);//å£°æ˜å‡½æ•°

int main(){
    int n, m; //næ˜¯ç»“ç‚¹æ•°ï¼Œmæ˜¯éå¶å­èŠ‚ç‚¹æ•°
    scanf("%d %d",&n,&m);
    //æ¥ä¸‹æ¥çš„mè¡Œ
    int node,num,id;
    //åˆå§‹åŒ–æ¯ä¸€å±‚
    for(int i=0;i<m;i++){
        scanf("%d %d",&node,&num);//scanfè¾“å…¥çš„æ—¶å€™åŠ ä¸åŠ ç©ºæ ¼æ— æ‰€è°“ ä½†æ˜¯è¾“å‡ºä¸€å®šè¦åŠ 
        for(int j=0;j<num;j++){
            scanf("%d",&id);
            child[node].push_back(id);//ç›¸å½“äºä¸€ä¸ªåŠ¨æ€æ•°ç»„ æ¯ä¸€ä¸ªnodeçš„å­èŠ‚ç‚¹çš„æ•°ç»„
        }
    }
    //æ·±åº¦ä¼˜å…ˆéå†
    dfs(1,0);
    printf("%d",cnt[0]);
    for(int i=1;i<=maxlevel;i++){
        printf(" %d",cnt[i]);
    }
    
    return 0;
}
//ä»æ ¹èŠ‚ç‚¹å¼€å§‹éå†æ•´æ£µæ ‘ 
//æ·±åº¦ä¼˜å…ˆ å°±æ˜¯é€’å½’ 
void dfs(int start,int level){
    //å¦‚æœå·²ç»æ˜¯å¶å­èŠ‚ç‚¹çš„è¯ï¼Œå°±è®¡æ•°
    if(child[start].size()==0){
        cnt[level]++;
        maxlevel=max(level,maxlevel);
        return ; //è¿™ä¸ªreturnå…¶å®æ˜¯å¶å­èŠ‚ç‚¹è¿”å› å¹¶ä¸ä¼šè·³å‡ºå‡½æ•°
    }
    //ä¸æ˜¯å¶å­èŠ‚ç‚¹å°±é€’å½’
    for(int i=0;i<child[start].size();i++){
        dfs(child[start][i],level+1);
    }
}
```

### **ğŸ“æŸ¥æ¼è¡¥ç¼º**

```c++
//BFSå’ŒDFSçš„çŸ¥è¯†è¯¦ç»†è¯·çœ‹ç®—æ³•
//è¾“å…¥çš„æ—¶å€™ç”±äºIDæ˜¯01ã€02ä¹‹ç±»çš„ï¼Œæˆ‘ä»¥ä¸ºè¦ç”¨stringï¼Œç»“æœæ•´æ•°è¾“å…¥å°±æ˜¯ä¸€æ ·çš„ã€‚è·ŸæŸ³ç¥å­¦çš„ç”¨scanfã€printfäº†~ä¸è¿‡cinã€coutæˆ‘è¯å®äº†ä¹Ÿæ˜¯ä¸€æ ·çš„
int n;
cin>>n;//n=01
cout<<n;//output:1
//vectorç›¸å½“äºåŠ¨æ€æ•°ç»„
#include<vector>
vector<int> v[xxx];//äºŒç»´æ•°ç»„
vector<int> v;//ä¸€ç»´æ•°ç»„
//å¸¸ç”¨çš„å‡½æ•°
push_back();
pop_back();
size();
//ğŸ“•è¯¦ç»†è¯·çœ‹ï¼šhttps://www.runoob.com/w3cnote/cpp-vector-container-analysis.html
```

## 1005 Spell It Right 

### **ğŸ“œé¢˜ç›®**

Given a non-negative integer *N*, your task is to compute the sum of all the digits of *N*, and output every digit of the sum in English.

Input Specification:

Each input file contains one test case. Each case occupies one line which contains an ***N* (â‰¤10^100).**

Output Specification:

For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line.

Sample Input:

```in
12345
```

Sample Output:

```out
one five
```

### **ğŸ¤”æ€è·¯**

çœ‹åˆ°é¢˜ç›®æ„Ÿè§‰è¿˜æ˜¯æŒºç®€å•çš„ï¼Œä¸»è¦æ˜¯è¾“å…¥çš„æ•°å­—<10^100ï¼Œæ„Ÿè§‰æœ‰ç‚¹å¤§å°±ä¸èƒ½ç”¨intäº†ï¼Œåˆšå¼€å§‹æœ¬æ¥æƒ³å°è¯•long intï¼Œä½†æ˜¯è¿˜æ˜¯ä¸å¤Ÿï¼Œåé¢å¾—çŸ¥stringè¾“å…¥å¯ä»¥è¿™ä¹ˆå¤§ï¼Œæ‰€ä»¥å°±ç”¨stringè¾“å…¥äº†ï¼Œé‡ç‚¹å°±æ˜¯å­—ç¬¦ä¸²è½¬æ•°å­—~

**ğŸ“•æ ¸å¿ƒæ€æƒ³ï¼š**è¿™ä¸€é¢˜çš„å…³é”®æ˜¯å°†å­—ç¬¦ä¸²è½¬æ¢æˆæ•°å­—ã€‚å­—ç¬¦ä¸²-'0'=æ•´æ•°ï¼å¼€å§‹æœ¬æ¥æƒ³ç”¨atoiå‡½æ•°ï¼Œä½†æ˜¯ç¼–è¯‘å‡ºé”™å°±æ²¡ç”¨äº†ã€‚Add:å¤§å†™å­—æ¯=å°å†™å­—æ¯-32 ï¼›å½“ç„¶è¿™é‡Œçš„32æˆ‘ä¹Ÿå¯ä»¥è¿™ä¹ˆå†™â€˜Zâ€™=â€˜zâ€™-'ç©ºæ ¼'ã€‚å› ä¸ºç©ºæ ¼çš„ASCIIç æ˜¯32å¯¹åº”çš„äºŒè¿›åˆ¶ç¼–ç ã€‚

### â­**ä»£ç **

```c++

#include<iostream>
#include<string>
using namespace std;

int main() {
	string s;
	cin >> s;
	int len = s.length();
	int sum = 0;
	for (int i = 0; i <len; i++) {
		//int num = atoi(s[i]);
		sum = sum + (s[i]-'0');
	}
	string res = to_string(sum);
	string arr[10] = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine" };
	for (int i = 0; i < res.length() - 1; i++) {
		cout << arr[res[i] - '0']<<" ";
	}
	cout << arr[res[res.length() - 1] - '0'];
	return 0;
}
```

### **ğŸ“æŸ¥æ¼è¡¥ç¼º**

```c++
//å­—ç¬¦ä¸²è½¬æ•°å­—
int num = s[i]-'0';
//è¿˜å¯ä»¥ç”¨åº“é‡Œé¢çš„å‡½æ•°stoi()/atoi()
```

## 1006 Sign In and Sign Out

### **ğŸ“œé¢˜ç›®**

At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in's and out's, you are supposed to find the ones who have unlocked and locked the door on that day.

Input Specification:

Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer *M*, which is the total number of records, followed by *M* lines, each in the format:

```
ID_number Sign_in_time Sign_out_time
```

where times are given in the format `HH:MM:SS`, and `ID_number` is a string with no more than 15 characters.

Output Specification:

For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space.

Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment.

Sample Input:

```in
3
CS301111 15:30:28 17:00:10
SC3021234 08:00:00 11:25:25
CS301133 21:45:00 21:58:40
```

Sample Output:

```out
SC3021234 CS301133
```

### **ğŸ¤”æ€è·¯**

ä¸€æ‹¿åˆ°é¢˜å°±çŸ¥é“æ€è·¯ï¼Œè¿™é“é¢˜è¿˜æ˜¯æŒºç®€å•çš„ï¼Œä½†æ˜¯åœ¨åšçš„è¿‡ç¨‹ä¸­ç”±äºçº ç»“è¦ä¸è¦åšå¾—ç®€å•äº›ï¼Œå°±æƒ³äº†å¾ˆå¤šï¼Œå¯¼è‡´æµªè´¹äº†å¾ˆå¤šæ—¶é—´ã€‚æœ€å¼€å§‹ï¼Œæˆ‘æƒ³çš„æ˜¯æŠŠhourã€minutesã€secondå•ç‹¬ä»æ•°ç»„ä¸­æ‹¿å‡ºæ¥æ¯”ï¼Œä½†æ˜¯å¤ªè¿‡äºéº»çƒ¦äº†ï¼Œäºæ˜¯è¯•éªŒäº†å­—ç¬¦ä¸²æ•°å­—çš„æ¯”å¤§å°ï¼Œç»è¯å®ï¼Œ"12:08:54"ä¸"03:12:34"æ˜¯å®Œå…¨å¯ä»¥æ¯”è¾ƒçš„ï¼Œæ‰€ä»¥æˆ‘å°±ç›´æ¥æ‹¿è¿‡æ¥æ¯”äº†ã€‚ä½†æ˜¯è¦è¾“å‡ºidï¼Œå¼€å§‹æˆ‘æƒ³çš„æ˜¯è¦ä¸è¦è®°å½•æœ€å¤§çš„ç„¶åè¿”å›æœ€å¤§å€¼çš„ç´¢å¼•å€¼ï¼Œè¦ç”¨vectoræˆ–è€…æ•°ç»„ä¸­è‡ªå¸¦çš„é‚£ä¸ªåœ°å€å‡½æ•°ï¼Œåé¢æƒ³ç€å¤ªéº»çƒ¦ï¼Œæ‰€ä»¥å°±ç›´æ¥æ¯ä¸€æ¬¡æ¯”è¾ƒæ¯ä¸€æ¬¡è®°å½•å°±è¡Œäº†ã€‚çœ‹äº†çœ‹æŸ³ç¥çš„ä»£ç ï¼ŒæŠŠæ—¶é—´è½¬æ¢æˆæ€»çš„æ•°å­—ï¼Œå¥½æœºæ™ºå“¦ï½ä¸æ„§æ˜¯æŸ³ç¥ï¼Œä»£ç ç®€æ´ï¼Œå–œæ¬¢ï¼ï¼ˆä½†æ˜¯æˆ‘è¿è¡Œçš„æ—¶å€™ æŠŠæ•°ç»„è®¾ç½®æˆ100å“ˆå“ˆå“ˆå“ˆæœ‰ç‚¹å·æ‡’ å› ä¸ºç§å¿ƒçŒœæµ‹æµ‹è¯•ç”¨ä¾‹åº”è¯¥ä¸ä¼šæœ‰è¿™ä¹ˆå¤šæ•°æ®å“ˆå“ˆå“ˆï¼‰

**ğŸ“•æ ¸å¿ƒæ€æƒ³ï¼š**æ¯ä¸€æ¬¡æ¯”è¾ƒï¼Œæ¥ä¿å­˜æœ€å¤§çš„timeå’Œæœ€å°çš„timeï¼ŒåŒæ—¶è®°å½•æ¯ä¸€æ¬¡æ¯”è¾ƒçš„idã€‚

### â­**ä»£ç **

```c++
#include<iostream>
#include<string>
using namespace std;

string c[101][3];//ç§å¿ƒå¼€äº†100 å“ˆå“ˆå“ˆå“ˆæœ‰ç‚¹å·æ‡’
int main(){
    int n;
    string id,time_in,time_out;
    string unlock="24:59:59";
    string lock="00:00:00";
	//è¾“å…¥
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>id>>time_in>>time_out;
        c[i][0]=id;
        c[i][1]=time_in;
        c[i][2]=time_out;
    }
    //æ¯”è¾ƒ
    string id_in,id_out;
    for(int i=0;i<n;i++){
        if(c[i][1]<unlock)//å­—ç¬¦ä¸²æ˜¯å¯ä»¥ç”¨æ¥ç›´æ¥æ¯”è¾ƒçš„
        {
            unlock=c[i][1];
            id_in=c[i][0];//æ¯ä¸€æ¬¡æ¯”è¾ƒæ›´æ–°ä¸€æ¬¡id
        }
    }
    for(int i=0;i<n;i++){
        if(c[i][2]>lock)
        {
            lock=c[i][2];
            id_out=c[i][0];
        }
    }
    cout<<id_in<<" "<<id_out;
    return 0;
}
```

æŸ³ç¥çš„ä»£ç ï¼š

```c++
#include <iostream>
#include <climits>//å®šä¹‰ä¸€äº›æœ€å€¼å¸¸é‡
using namespace std;
int main() {
    int n, minn = INT_MAX, maxn = INT_MIN;
    scanf("%d", &n);
    string unlocked, locked;
    for(int i = 0; i < n; i++) {//ä¸€æ¬¡æ€§ä¸€ä¸ªå¾ªç¯
        string t;
        cin >> t;
        int h1, m1, s1, h2, m2, s2;
        scanf("%d:%d:%d %d:%d:%d", &h1, &m1, &s1, &h2, &m2, &s2);
        int tempIn = h1 * 3600 + m1 * 60 + s1;
        int tempOut = h2 * 3600 + m2 * 60 + s2;
        if (tempIn < minn) {
            minn = tempIn;
            unlocked = t;
        }
        if (tempOut > maxn) {
            maxn = tempOut;
            locked = t;
        }
    }
    cout << unlocked << " " << locked;
    return 0;
}
```

### **ğŸ“æŸ¥æ¼è¡¥ç¼º**

```c++
#include <climits>//å®šä¹‰ä¸€äº›æœ€å€¼å¸¸é‡
int minn = INT_MAX, maxn = INT_MIN;
//é€šè¿‡ifè¯­å¥æ¥æ‰¾åˆ°æœ€å€¼çš„ç´¢å¼•
```

## 1007 **Maximum Subsequence Sum**

### **ğŸ“œé¢˜ç›®**

Given a sequence of *K* integers { *N*1, *N*2, ..., *N**K* }. A continuous subsequence is defined to be { *N**i*, *N**i*+1, ..., *N**j* } where 1â‰¤*i*â‰¤*j*â‰¤*K*. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.

Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.

Input Specification:

Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer *K* (â‰¤10000). The second line contains *K* numbers, separated by a space.

Output Specification:

For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices *i* and *j* (as shown by the sample case). If all the *K* numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.

Sample Input:

```in
10
-10 1 2 3 4 -5 -23 3 7 -21
```

Sample Output:

```out
10 1 4
```

### **ğŸ¤”æ€è·¯**

å“é‡åˆ°åŠ¨è§„çš„é¢˜æ¯æ¬¡éƒ½æ˜¯æƒ³ä¸åˆ°çªç ´ç‚¹,è„‘ç“œå­å¤ªç¬¨å•¦ğŸ˜­ç•éš¾è€Œå¾ˆå°‘åšè¿™ç±»é¢˜,æ‰€ä»¥è¦å¤šå¤šç»ƒä¹ å•Š!çœ‹äº†æŸ³ç¥çš„ä»£ç ,æ„Ÿè§‰è±ç„¶å¼€æœ—,æŸ³ç¥ç‰›é€¼!

**ğŸ“•æ ¸å¿ƒæ€æƒ³:**åˆ†æï¼šsumä¸ºè¦æ±‚çš„æœ€å¤§å’Œï¼Œtempä¸ºä¸´æ—¶æœ€å¤§å’Œï¼Œleftindexå’Œrightindexä¸ºæ‰€æ±‚çš„å­åºåˆ—çš„ä¸‹æ ‡ï¼Œtempindexæ ‡è®°leftçš„ä¸´æ—¶ä¸‹æ ‡ï½

temp = temp + v[i]ï¼Œå½“tempæ¯”sumå¤§ï¼Œå°±æ›´æ–°sumçš„å€¼ã€leftindexå’Œrightindexçš„å€¼ï¼›**å½“temp < 0ï¼Œé‚£ä¹ˆåé¢ä¸ç®¡æ¥ä»€ä¹ˆå€¼ï¼Œéƒ½åº”è¯¥èˆå¼ƒtemp < 0å‰é¢çš„å†…å®¹**ï¼Œå› ä¸ºè´Ÿæ•°å¯¹äºæ€»å’Œåªå¯èƒ½æ‹‰ä½æ€»å’Œï¼Œä¸å¯èƒ½å¢åŠ æ€»å’Œï¼Œè¿˜ä¸å¦‚èˆå¼ƒï½

èˆå¼ƒåï¼Œç›´æ¥ä»¤temp = 0ï¼Œå¹¶ä¸”åŒæ—¶æ›´æ–°leftçš„ä¸´æ—¶å€¼tempindexã€‚å› ä¸ºå¯¹äºæ‰€æœ‰çš„å€¼éƒ½ä¸ºè´Ÿæ•°çš„æƒ…å†µè¦è¾“å‡º0ï¼Œç¬¬ä¸€ä¸ªå€¼ï¼Œæœ€åä¸€ä¸ªå€¼ï¼Œæ‰€ä»¥åœ¨è¾“å…¥çš„æ—¶å€™ç”¨flagåˆ¤æ–­æ˜¯ä¸æ˜¯æ‰€æœ‰çš„æ•°å­—éƒ½æ˜¯å°äº0çš„ï¼Œå¦‚æœæ˜¯ï¼Œè¦åœ¨è¾“å…¥çš„æ—¶å€™ç‰¹æ®Šå¤„ç†ï½

### â­**ä»£ç **

```c++
#include <iostream>
#include <vector>
using namespace std;
int main() {
    int n;
    scanf("%d", &n);
    vector<int> v(n);//ç”³è¯·vector
    int leftindex = 0, rightindex = n - 1, sum = -1, temp = 0, tempindex = 0;
    for (int i = 0; i < n; i++) {
        scanf("%d", &v[i]);
        temp = temp + v[i];
        if (temp < 0) {//å°äº0å°±èˆå» å·¦ä¸‹æ ‡æ›´æ–°åˆ°ä¸‹ä¸€ä¸ªä½ç½®
            temp = 0;
            tempindex = i + 1;//tempindexä¸€å®šè¦æœ‰
        } 
        else if (temp > sum) {
            sum = temp;
            //ä¸ºäº†ä½¿å¾—æ»¡è¶³æœ€å…ˆå‡ºç°çš„ä¸‹æ ‡(å¦‚æœé‡åˆ°ç›¸åŒçš„)
            leftindex = tempindex;//ä¸å˜å°±ä¸å˜,ä¸‹æ ‡æ›´æ–°å°±ç›¸åº”æ”¹å˜
            rightindex = i;
        }
    }
    if (sum < 0) sum = 0;//å¦‚æœæ‰€æœ‰temp<0,åˆ™sum=-1,æ‰€ä»¥å…¨ä¸ºè´Ÿæ•°
    printf("%d %d %d", sum, v[leftindex], v[rightindex]);
    return 0;
}
```

### **ğŸ“æŸ¥æ¼è¡¥ç¼º**

```c++
//DPè¯¦æƒ…çœ‹ç®—æ³•
```



## 1008 Elevator

### **ğŸ“œé¢˜ç›®**

The highest building in our city has only one elevator. A request list is made up with *N* positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop.

For a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled.

Input Specification:

Each input file contains one test case. Each case contains a positive integer *N*, followed by *N* positive numbers. All the numbers in the input are less than 100.

Output Specification:

For each test case, print the total time on a single line.

Sample Input:

```in
3 2 3 1
```

Sample Output:

```out
41
```

### **ğŸ¤”æ€è·¯**

è¿™é“é¢˜å¾ˆç®€å•ï¼Œåˆšå¼€å§‹æˆ‘åˆç”¨æ•°ç»„è¾“å…¥å“ˆå“ˆå“ˆä¸ºäº†å®šä½ï¼Œè¯•äº†105ï¼Œè¯æ˜å¯è¡Œï¼Œä½†æ˜¯åé¢è¿˜æ˜¯æ”¹æˆé€šç”¨çš„äº†ã€‚è¿™é“é¢˜å¼€å§‹æˆ‘æ˜¯éƒ¨åˆ†é€šè¿‡ï¼Œå› ä¸ºè¿™é¢˜ç›®æ²¡è¯´æ˜ç™½ï¼Œå¦‚æœæœ‰ä¸¤ä¸ªè¿ç»­çš„é‡å¤çš„ï¼Œé‚£å°±åº”è¯¥åªåœæ­¢5så•Šï¼ˆåŒä¸€å±‚å°±ä¸€èµ·å°±ä¸‹äº†å‘—...ç™½ç™½æµªè´¹å…¶ä»–æ—¶é—´å¹²å˜›ï¼‰å°±å¾ˆæ‰¯ï¼Œé¢˜ç›®æœ‰æ­§ä¹‰ã€‚ç„¶åæ”¹æˆelseå°±å…¨éƒ¨é€šè¿‡äº†ã€‚

**ğŸ“•æ ¸å¿ƒæ€æƒ³ï¼š**æ¯æ¬¡æ¯”è¾ƒæ¥ç´¯åŠ è®¡æ•°ã€‚

### â­**ä»£ç **

```c++
#include<iostream>
using namespace std;

int main(){
    int n,level,now=0,time=0;
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>level;
        if(level>now)//ç”µæ¢¯ä¸Šå‡
            time = time + (level-now)*6+5;
        else //ç”µæ¢¯ä¸‹é™ ä¸èƒ½ç”¨if å› ä¸ºå¯èƒ½ç›¸ç­‰
            time = time + (now-level)*4+5;
        now = level;
    }
    cout<<time;
    return 0;
}
```

### **ğŸ“æŸ¥æ¼è¡¥ç¼º**

## 1009 Product of Polynomials

### **ğŸ“œé¢˜ç›®**

This time, you are supposed to find *A*Ã—*B* where *A* and *B* are two polynomials.

Input Specification:

Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:

*K* *N*1 *aN*1 *N*2 *aN*2 ... *NK* *a**N**K*

where *K* is the number of nonzero terms in the polynomial, *Ni* and *a**N**i* (*i*=1,2,â‹¯,*K*) are the exponents and coefficients, respectively. It is given that 1â‰¤*K*â‰¤10, 0â‰¤*NK*<â‹¯<*N*2<*N*1â‰¤1000.

Output Specification:

For each test case you should output the product of *A* and *B* in one line, with the same format as the input. Notice that there must be **NO** extra space at the end of each line. Please be accurate up to 1 decimal place.

Sample Input:

```in
2 1 2.4 0 3.2
2 2 1.5 1 0.5
```

Sample Output:

```out
3 3 3.6 2 6.0 1 1.6
```

### **ğŸ¤”æ€è·¯**

é¢˜ç›®çœ‹äº†æˆ‘å¥½ä¹…...æƒ¯æ€§æ€ç»´æŠŠæ•°å­¦å¤šé¡¹å¼å¸¦è¿›å»ç›¸ä¹˜ï¼Œç»“æœåŠå¤©å¾—ä¸å‡ºæ¥ç»“æœï¼Œç»“æœå‘ç°ç³»æ•°ä¸åŒçš„æŒ‡æ•°ä¹Ÿå¯ä»¥ç›¸åŠ ...(è¿™æœ‰ç‚¹åæ•°å­¦äº†å“ˆ)è¯»æ‡‚é¢˜ç›®ä¹‹åå°±æ„Ÿè§‰è¿˜è›®ç®€å•çš„ï¼Œç”¨æš´åŠ›è§£æ³•ï¼Œå¯¹äºç¬¬ä¸€ç»„å¤šé¡¹å¼çš„æ¯ä¸€ä¸ªç³»æ•°è·Ÿç¬¬äºŒç»„çš„æ¯ä¸€ä¸ªç›¸ä¹˜ï¼Œç„¶åå¯¹åº”çš„æŒ‡æ•°ç›¸åŠ ã€‚exp_ansçš„ä¸‹æ ‡å°±è¡¨ç¤ºæŒ‡æ•°ï¼Œå†…å®¹å°±è¡¨ç¤ºç³»æ•°ã€‚

**ğŸ“•æ ¸å¿ƒæ€æƒ³**ï¼šæŒ‡æ•°ç”¨äºä¸‹æ ‡ï¼Œæ•°ç»„çš„å†…å®¹æ‰æ˜¯ç³»æ•°ã€‚

### â­**ä»£ç **

```c++
#include<iostream>
using namespace std;

int exp_1[11], exp_2[11];//ä¸¤ç»„æ•°æ®çš„æŒ‡æ•°
float coef1[11], coef2[11];//ä¸¤ç»„æ•°æ®çš„ç³»æ•°
float exp_ans[2001] = { 0.0 }; //ç»“æœ
int cnt = 0;
int main() {
	int n, m;//ä¸¤ç»„æ•°æ®çš„éé›¶é¡¹æ•°
	//è¾“å…¥æ•°æ®
	cin >> n;
	for (int i = 0; i < n; i++) {
		cin >> exp_1[i] >> coef1[i];
	}
	cin >> m;
	for (int i = 0; i < m; i++) {
		cin >> exp_2[i] >> coef2[i];
	}
	//è®¡ç®—
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			exp_ans[exp_1[i] + exp_2[j]] += coef1[i] * coef2[j];
		}
	}
	for (int i = 2000; i >= 0; i--) {
		if (exp_ans[i] != 0.0) {
			cnt++;
		}
	}
	cout << cnt;
	for (int i = 2000; i >= 0; i--) {
		if (exp_ans[i] != 0.0) {
			printf(" %d %.1f", i, exp_ans[i]);
		}
	}
	return 0;
}
```

æŸ³ç¥ä»£ç ï¼šï¼ˆå¤§ä½“ä¸Šå·®ä¸å¤š ä½†æ˜¯æ›´ä¸ºç®€æ´ï¼‰

```c++
#include <iostream>
using namespace std;
int main() {
    int n1, n2, a, cnt = 0;
    scanf("%d", &n1);
    double b, arr[1001] = {0.0}, ans[2001] = {0.0};
    for(int i = 0; i < n1; i++) {
        scanf("%d %lf", &a, &b);
        arr[a] = b;
    }
    scanf("%d", &n2);
    for(int i = 0; i < n2; i++) {
        scanf("%d %lf", &a, &b);
        for(int j = 0; j < 1001; j++)
                ans[j + a] += arr[j] * b;
    }
    for(int i = 2000; i >= 0; i--)
        if(ans[i] != 0.0) cnt++;
    printf("%d", cnt);
    for(int i = 2000; i >= 0; i--)
        if(ans[i] != 0.0)
            printf(" %d %.1f", i, ans[i]);
    return 0;
}
```

### **ğŸ“æŸ¥æ¼è¡¥ç¼º**

æ— 

## 1010 **Radix** 

### **ğŸ“œé¢˜ç›®**

Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is `yes`, if 6 is a decimal number and 110 is a binary number.

Now for any pair of positive integers *N*1 and *N*2, your task is to find the radix of one number while that of the other is given.

Input Specification:

Each input file contains one test case. Each case occupies a line which contains 4 positive integers:

```
N1 N2 tag radix
```

Here `N1` and `N2` each has no more than 10 digits. A digit is less than its radix and is chosen from the set { 0-9, `a`-`z` } where 0-9 represent the decimal numbers 0-9, and `a`-`z` represent the decimal numbers 10-35. The last number `radix` is the radix of `N1` if `tag` is 1, or of `N2` if `tag` is 2.

Output Specification:

For each test case, print in one line the radix of the other number so that the equation `N1` = `N2` is true. If the equation is impossible, print `Impossible`. If the solution is not unique, output the smallest possible radix.

Sample Input 1:

```in
6 110 1 10
```

Sample Output 1:

```out
2
```

Sample Input 2:

```in
1 ab 1 2
```

Sample Output 2:

```out
Impossible
```

### **ğŸ¤”æ€è·¯**

ä¸€é“è¿›åˆ¶è½¬æ¢é¢˜ç›®ï¼Œä½†æ˜¯...é€šç”¨å‹è½¬æ¢æ„Ÿè§‰è¿˜æ˜¯æœ‰ç‚¹å¤æ‚ã€‚å¦‚æœç»™å‡ºäº†N1çš„åŸºæ•°ï¼Œé‚£ä¹ˆå°±å°†N1ä¾æ¬¡ä»å¤§åˆ°å°è½¬æ¢2-36è¿›åˆ¶çš„æ•°ï¼Œæ¥å¯¹æ¯”N2ï¼Œçœ‹æ˜¯å¦ä¸€æ ·(æ„Ÿè§‰æœ‰äº›å¤æ‚...æœ€ç»ˆæµ‹è¯•æœ‰äº›è¿˜è¶…æ—¶äº†...æˆ‘æŒ‰ç…§æ¨¡æ¿å¥—ç”¨äº†xè¿›åˆ¶è½¬yè¿›åˆ¶ï¼Œç»“æœæ˜¯éƒ¨åˆ†é€šè¿‡ã€‚è¿™é¢˜å‘æœ‰ç‚¹å¤šå•ŠğŸ˜­æ‰€ä»¥æœ€ç»ˆè¿˜æ˜¯å‚è€ƒäº†æŸ³ç¥çš„ä»£ç ï½

**ğŸ“•æ ¸å¿ƒæ€æƒ³ï¼š**å°†å·²çŸ¥åŸºæ•°çš„æ•°è½¬åŒ–æˆåè¿›åˆ¶æ•°,ç„¶åç”¨**äºŒåˆ†æŸ¥æ‰¾æ³•**ä¾æ¬¡åŸºæ•°ä»å¤§åˆ°å°æŸ¥æ‰¾(èŒƒå›´æ˜¯(æœ€å¤§åŸºä½æ•°+1,å·²çŸ¥åè¿›åˆ¶)) å·²çŸ¥å‘ç‚¹:1ã€æœ€å¤§çš„è¿›åˆ¶ä¸å±€é™äº36ã€‚2ã€è½¬åŒ–ä¸ºåè¿›åˆ¶æ•°å¯èƒ½äº§ç”Ÿæº¢å‡ºã€‚é¢˜ç›®çœ‹ä¼¼ç®€å•ä½†æ˜¯æƒ³è¦ACè¿˜æ˜¯æŒºéš¾çš„ã€‚

### â­**ä»£ç **

```c++
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;

//éƒ¨åˆ†é€šè¿‡ 16åˆ† æœ‰äº›æµ‹è¯•é›†è¶…æ—¶äº†...å®åœ¨ä¸æƒ³æ”¹äº† åé¢å°±å‚ç…§æŸ³ç¥çš„ä»£ç 
int main() {
	int tag, radix;
	string N1, N2;
	cin >> N1 >> N2 >> tag >> radix;
	if (tag == 1) {//radixæ˜¯N1çš„åŸºæ•°
		int ans = 0;
		int len = N1.length();
		for (int i = 0; i < len; i++) {//å˜æˆ10è¿›åˆ¶
			ans = ans * radix;
			if (N1[i] >= '0' && N1[i] <= '9')
				ans += N1[i] - '0';
			else
				ans += (N1[i] - 'a') + 10;
		}
		int dec = ans;
		int k = 0;
		for (int i = 2; i <= 36; i++) {
			string s = "000000000000000000";
			int cnt = 0;
			ans = dec;//ä¾æ¬¡å¯»æ‰¾å¯¹åº”çš„åŸºæ•°
			while (ans > 0) {
				int w = (ans % i);
				if (w < 10) s[cnt++] = w + '0';
				else s[cnt++] = (w - 10) + 'a';
				ans /= i;
			}
			s = s.substr(0, cnt);
			reverse(s.begin(), s.end());
			//cout << s << endl;
			if (s == N2)
			{
				cout << i;
				break;
			}
			else k++;
		}
		if (k == 35)
			cout << "Impossible";
	}
	else if (tag == 2) {
		int ans = 0;
		int len = N2.length();
		for (int i = 0; i < len; i++) {
			ans = ans * radix;
			if (N2[i] >= '0' && N2[i] <= '9')
				ans += N2[i] - '0';
			else
				ans += (N2[i] - 'a') + 10;
		}
		int dec = ans;
		int k = 0;
		for (int i = 2; i <= 36; i++) {
			string s = "000000000000000000";
			int cnt = 0;
			ans = dec;//ä¾æ¬¡å¯»æ‰¾å¯¹åº”çš„åŸºæ•°
			while (ans > 0) {
				int w = (ans % i);
				if (w < 10) s[cnt++] = w + '0';
				else s[cnt++] = (w - 10) + 'a';
				ans /= i;
			}
			s = s.substr(0, cnt);
			reverse(s.begin(), s.end());
			if (s == N1)
			{
				cout << i;
				break;
			}
			else k++;
		}
		if (k == 35)
			cout << "Impossible";
	}
	return 0;
}
```

**æŸ³ç¥ä»£ç **

```c++
#include <iostream>
#include <cctype>
#include <algorithm>
#include <cmath>
using namespace std;

//å°†å®ƒè½¬åŒ–ä¸º10è¿›åˆ¶ã€‚è½¬åŒ–è¿‡ç¨‹ä¸­å¯èƒ½äº§ç”Ÿæº¢å‡º
long long convert(string n, long long radix) {
    long long sum = 0;//ä¼šæº¢å‡ºæ‰€ä»¥å°±ç”¨çš„long long
    int index = 0, temp = 0;
    for (auto it = n.rbegin(); it != n.rend(); it++) {
        //é€†åºè¿­ä»£ ä»ä½ä½åˆ°é«˜ä½ä¾æ¬¡è½¬æ¢
        temp = isdigit(*it) ? *it - '0' : *it - 'a' + 10;
        sum += temp * pow(radix, index++);
    }
    return sum;
}
//find_radixå‡½æ•°ï¼šæ‰¾åˆ°ä»¤ä¸¤ä¸ªæ•°å€¼ç›¸ç­‰çš„è¿›åˆ¶æ•°ã€‚åœ¨æŸ¥æ‰¾çš„è¿‡ç¨‹ä¸­ï¼Œéœ€è¦ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾ç®—æ³•ï¼Œå¦‚æœä½¿ç”¨å½“å‰è¿›åˆ¶è½¬åŒ–å¾—åˆ°æ•°å€¼æ¯”å¦ä¸€ä¸ªå¤§æˆ–è€…å°äº0ï¼Œè¯´æ˜è¿™ä¸ªè¿›åˆ¶å¤ªå¤§ï½
//è¾“å…¥:æœªçŸ¥çš„æ•°,å·²çŸ¥æ•°çš„åè¿›åˆ¶
long long find_radix(string n, long long num) {
    char it = *max_element(n.begin(), n.end());//STL
    long long low = (isdigit(it) ? it - '0': it - 'a' + 10) + 1; //æœ€ä½æ˜¯æœ€å¤§çš„ä¸€ä½å€¼åŠ ä¸Š1
    //numè¡¨ç¤ºå·²çŸ¥æ•°çš„åè¿›åˆ¶,è‹¥lowæ¯”numè¦å¤§ é‚£è‚¯å®šè½¬æ¢ä¸äº†
    //æ¯”å¦‚è¯´110 5 1 2 110è½¬æˆ4, è€Œ5æ¯”4å¤§,è‚¯å®šè¡¨ç¤ºä¸äº†äº†
    long long high = max(num, low);
    while (low <= high) {
        long long mid = (low + high) / 2;//äºŒåˆ†æŸ¥æ‰¾
        long long t = convert(n, mid); //ç»äº†!
        if (t < 0 || t > num) high = mid - 1;
        else if (t == num) return mid;
        else low = mid + 1;
    }
    return -1;
}
int main() {
    string n1, n2;
    long long tag = 0, radix = 0, result_radix;
    cin >> n1 >> n2 >> tag >> radix;
    result_radix = tag == 1 ? find_radix(n2, convert(n1, radix)) : find_radix(n1, convert(n2, radix));
    if (result_radix != -1) {
        printf("%lld", result_radix);
    } else {
        printf("Impossible");
    }   
    return 0;
}
```

å¦å¤–:https://blog.csdn.net/qq_41173604/article/details/94895471è¿™ä¸ªåšä¸»çš„ä»£ç ä¹Ÿå¾ˆæ¸…æ™°æ˜äº†ã€‚

### **ğŸ“æŸ¥æ¼è¡¥ç¼º**

```c++
//auto
//autoè¡¨ç¤ºè‡ªåŠ¨å˜é‡ï¼Œå¯ä»¥è‡ªåŠ¨æ¨æ–­ç»™å‡ºçš„å˜é‡çš„ç±»å‹ã€‚https://www.cnblogs.com/KunLunSu/p/7861330.html
//æº¢å‡ºä¹‹åæ˜¯è´Ÿæ•°->è®¡ç®—æœºç»„æˆåŸç†çš„çŸ¥è¯†
```

